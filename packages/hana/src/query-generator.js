import { table } from 'console';
import {
  attributeTypeToSql,
  normalizeDataType,
} from '@sequelize/core/_non-semver-use-at-your-own-risk_/abstract-dialect/data-types-utils.js';
import { joinSQLFragments } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/join-sql-fragments.js';
import { EMPTY_OBJECT } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/object.js';
import { rejectInvalidOptions } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/check.js';
import {
  ADD_COLUMN_QUERY_SUPPORTABLE_OPTIONS,
  CREATE_SCHEMA_QUERY_SUPPORTABLE_OPTIONS,
  CREATE_TABLE_QUERY_SUPPORTABLE_OPTIONS,
} from '@sequelize/core/_non-semver-use-at-your-own-risk_/abstract-dialect/query-generator.js';

import each from 'lodash/each';

import { HanaQueryGeneratorTypeScript } from './query-generator-typescript.internal.js';

const ADD_COLUMN_QUERY_SUPPORTED_OPTIONS = new Set();
const CREATE_SCHEMA_QUERY_SUPPORTED_OPTIONS = new Set();
const CREATE_TABLE_QUERY_SUPPORTED_OPTIONS = new Set(['comment', 'uniqueKeys']);

export class HanaQueryGenerator extends HanaQueryGeneratorTypeScript {
  // createSchemaQuery(schemaName, options) {
  //   // https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-sql-reference-guide/create-schema-statement-data-definition
  //   if (options) {
  //     rejectInvalidOptions(
  //       'createSchemaQuery',
  //       this.dialect.name,
  //       CREATE_SCHEMA_QUERY_SUPPORTABLE_OPTIONS,
  //       CREATE_SCHEMA_QUERY_SUPPORTED_OPTIONS,
  //       options,
  //     );
  //   }

  //   return `CREATE SCHEMA ${this.quoteIdentifier(schemaName)};`;
  // }

  // dropSchemaQuery(schemaName) {
  //   // https://help.sap.com/docs/HANA_SERVICE_CF/7c78579ce9b14a669c1f3295b0d8ca16/20d7891d751910149164f0d4ca73639d.html
  //   // https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-sql-reference-guide/drop-schema-statement-data-definition
  //   return `DROP SCHEMA ${this.quoteIdentifier(schemaName)};`;
  // }

  createTableQuery(tableName, attributes, options) {
    if (options) {
      rejectInvalidOptions(
        'createTableQuery',
        this.dialect.name,
        CREATE_TABLE_QUERY_SUPPORTABLE_OPTIONS,
        CREATE_TABLE_QUERY_SUPPORTED_OPTIONS,
        options,
      );
    }
    // todo
    // https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-sql-reference-guide/create-table-statement-data-definition

    options = {
      tableType: 'COLUMN',
      ...options
    };
    const primaryKeys = [];
    const foreignKeys = {};
    const attrStr = [];
    let columnComments = '';

    const quotedTable = this.quoteTable(tableName);

    for (const attr in attributes) {
      if (!Object.hasOwn(attributes, attr)) {
        continue;
      }

      const quotedAttr = this.quoteIdentifier(attr);
      let dataType = attributes[attr];
      let match;

      const commentIndex = dataType.indexOf('COMMENT ');
      if (commentIndex !== -1) {
        const commentText = dataType.slice(commentIndex + 8);
        const escapedCommentText = this.escape(commentText);
        columnComments += ` COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText};`;

        // remove comment related substring from dataType
        dataType = dataType.slice(0, commentIndex);
      }

      if (dataType.includes('PRIMARY KEY')) {
        primaryKeys.push(attr);

        if (dataType.includes('REFERENCES')) {
          match = dataType.match(/^(.+) (REFERENCES.*)$/);
          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);
          foreignKeys[attr] = match[2];
        } else {
          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);
        }
      } else if (dataType.includes('REFERENCES')) {
        match = dataType.match(/^(.+) (REFERENCES.*)$/);
        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);
        foreignKeys[attr] = match[2];
      } else {
        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);
      }
    }
    const table = this.quoteTable(tableName);
    let attributesClause = attrStr.join(', ');

    // todo  delete this - start
    attributesClause = attrStr.map(
      x=>x.replace(/\bAUTOINCREMENT\b/,
      'GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1)')
    )
    .map(x => x.replace(/ENUM\((".*?")(,\s*(".*?"))+\)/, (s) => {
      const enums = [];
      const regex = /"(.*?)"/g;
      let match = regex.exec(s);
      while(match !== null) {
        enums.push(match[1]);
        match = regex.exec(s);
      }
      const maxLength = Math.max(...enums.map(x=>x.length), 255);
      return `NVARCHAR(${maxLength})`;
    }))
    .join(', ');
    // delete this - end
    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');

    if (options.uniqueKeys) {
      //todo
      each(options.uniqueKeys, (columns, indexName) => {
        if (typeof indexName !== 'string') {
          indexName = `uniq_${tableName}_${columns.fields.join('_')}`;
        }

        attributesClause += `, CONSTRAINT ${
          this.quoteIdentifier(indexName)
        } UNIQUE (${
          columns.fields.map(field => this.quoteIdentifier(field))
            .join(', ')
        })`;
      });
    }

    if (pkString.length > 0) {
      attributesClause += `, PRIMARY KEY (${pkString})`;
    }

    for (const fkey in foreignKeys) {
      if (Object.hasOwn(foreignKeys, fkey)) {
        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;
      }
    }

    return joinSQLFragments([
      'CREATE',
      options.tableType,
      'TABLE',
      table,
      `(${attributesClause})`,
      options.comment && typeof options.comment === 'string' && `COMMENT ${this.escape(options.comment)}`,
      ';',
      columnComments,
    ]);
  }

  addColumnQuery(table, key, dataType, options) {
    if (options) {
      rejectInvalidOptions(
        'addColumnQuery',
        this.dialect.name,
        ADD_COLUMN_QUERY_SUPPORTABLE_OPTIONS,
        ADD_COLUMN_QUERY_SUPPORTED_OPTIONS,
        options,
      );
    }

    dataType = {
      ...dataType,
      type: normalizeDataType(dataType.type, this.dialect),
    };

    return joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(table),
      'ADD',
      '(',
      this.quoteIdentifier(key),
      this.attributeToSQL(dataType, {
        context: 'addColumn',
        tableName: table,
        foreignKey: key,
      }),
      ')',
      ';',
    ]);
  }

  changeColumnQuery(tableName, attributes) {
    //todo
  }

  renameColumnQuery(tableName, attrBefore, attributes) {
    //todo
  }

  truncateTableQuery(tableName) {
    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;
  }

  deleteQuery(tableName, where, options = EMPTY_OBJECT, model) {
    let query = `DELETE FROM ${this.quoteTable(tableName)}`;

    const escapeOptions = { ...options, model };
    const whereSql = this.whereQuery(where, escapeOptions);
    if (whereSql) {
      query += ` ${whereSql}`;
    }

    if (options.limit) {
      query += ` LIMIT ${this.escape(options.limit, escapeOptions)}`;
    }

    return query;
  }

  attributeToSQL(attribute, options) {
    //todo
  }

  attributesToSQL(attributes, options) {
    //todo
  }
}
